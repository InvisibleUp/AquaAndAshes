; hl = object RAM pointer
; uses A register as scratch
; uses D register for temp storage
; uses E register for temp storage
GetScreenX:
	push hl
	; Load FieldX into hl
	ld hl, FieldX
	ld a, [hl+]
	ld d, a
	ld a, [hl+]
	ld h, d
	ld l, a

	; Load ObjX into de
	pop bc
	push bc
	ld a, [bc]
	inc bc
	ld d, a
	ld a, [bc]
	inc bc
	ld e, a

	; ObjX - FieldX (as -FieldX + ObjX)
	NegateHL
	add hl, de

	; Get low byte and exit
	ld a, l
	pop hl
ret

; de = mapping offset
; b = object x
DrawSprite:
push hl
push de
pop hl

	; A, D and E are free now
	ld a, [hl+]
	ld e, a ; E = number of sprites

pop hl
ret

; c = src
; hl = dest
RenderFox:
	; Render body

ret

; c = src
; hl = dest
RenderGecko:
	;; Top-left
	; Store attributes
	ld a, [$ff00+c]
	ld e, a
	inc c
	; Y
	ld a, [$ff00+c]
	sub a, 16
	ld [hl+], a
	inc c
	; X
	ld a, [$ff00+c]

	ld b, a
	; add or subtract 8 depending on direction
	ld a, e
	and a, %10000 ; Direction
	ld d, a
	or a, d
	sub a, 8 ; Make 8 or -8
	add a, b

	ld [hl+], a
	inc c
	; Tile (from start)
	ld a, gecko_standing_tile
	ld [hl+], a
	; Attributes
	ld a, e
	and a, %10000 ; Direction
	sla a ; Shift to direction flag pos
	ld [hl+], a

	; Set src to last sprite
	ld d, h
	ld e, l
	dec de
	dec de
	dec de
	dec de

	; Rewind object pointer
	dec c
	dec c
	dec c

	;; Bottom-right
	; Y (+16)
	ld a, [de]
	add a, 16
	ld [hl+], a
	inc de
	; X (same)
	ld a, [de]
	ld [hl+], a
	inc de
	; Tile (plus 2)
	ld a, [de]
	add a, 2
	ld [hl+], a
	inc de
	; Attributes (same)
	ld a, [de]
	ld [hl+], a
	inc de

	;; Top-right
	; Y (-16)
	ld a, [de]
	sub a, 16
	ld [hl+], a
	inc de
	; X, add or subtract 8 depending on direction
	ld a, [de]
	ld b, a
	ld a, [$ff00+c]
	and a, %10000 ; Direction
	cpl ; Negate if left, noop if right
	inc a ; Adjust for cpl
	add a, 8
	add a, b
	ld [hl+], a
	inc de
	; Tile (plus 2)
	ld a, [de]
	add a, 2
	ld [hl+], a
	inc de
	; Attributes (same)
	ld a, [de]
	ld [hl+], a
	inc de

	;; Bottom-right
	; Y (+16)
	ld a, [de]
	add a, 16
	ld [hl+], a
	inc de
	; X (same)
	ld a, [de]
	ld [hl+], a
	inc de
	; Tile (plus 2)
	ld a, [de]
	add a, 2
	ld [hl+], a
	inc de
	; Attributes (same)
	ld a, [de]
	ld [hl+], a
	inc de
ret

RenderBucket:
ret

RenderTorch:
ret

; No arguments
; Uses A, C, HL registers
; Converts everything in object table to something usable by DMA
; c = OBJ HiRAM offset
; hl = Sprite Table offset
BakeSprites:
	ld c, (charRenderStruct_end - charRenderStruct) / charSizeOf
	ld hl, SpriteTable
	ld c, $80

.Loop
	; Test if sprite is active
	ld a, [$ff00+c]
	;bit 7, [hl]
	bit 7, a
	jr z, .CheckDone

	; Test for team
	bit 6, a
	jr z, .Gecko

.ArcticFox
	; Test for object type
	bit 5, a
	call z, RenderFox
	call nz, RenderBucket
	jr .CheckDone
.Gecko
	bit 5, a
	call z, RenderGecko
	call nz, RenderTorch

.CheckDone
	ld a, c
	add a, charRenderSizeOf
	ld c, a
	cp a, ($80 + charRenderStruct_end - charRenderStruct)
	jr nz, .Loop

ret

PrepareSprites:
	ld hl, charStruct
	ld c, $80
.loop:
	; Info bitfield
	ld a, [hl+]
	ld [$ff00+c], a
	inc c

	; Y
	ld a, [hl+]
	ld [$ff00+c], a
	inc c

	; X
	;call GetScreenX
	inc hl
	ld a, [hl+]
	ld b, a
	ld a, [FieldX+1]
	sub a, b
	ld [$ff00+c], a 
	inc c
	inc hl ; Dx
	inc hl ; Dy
	inc hl ; Speed
	;inc hl ; Timer

	; Animation timer
	ld a, [hl+]
	ld [$ff00+c], a
	inc c

	ld de, charStruct_end
	ld a, e
	sub a, l
	jr nz, .loop
	ld a, d
	sub a, h
	jr nz, .loop

ret

; Don't call directly!
SpriteDMA:
	ld a, SpriteTable / $100
	ldh [$FF46], a ;start DMA transfer (starts right after instruction)
	ld  a, $28     ;delay...
.wait:                 ;total 5x40 cycles, approx 200ms
	dec a          ;1 cycle
	jr  nz, .wait  ;4 cycles
	ret
SpriteDMA_End:
