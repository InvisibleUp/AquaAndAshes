; hl = object RAM pointer
; uses A register as scratch
; uses D register for temp storage
; uses E register for temp storage
GetScreenX:
	push de
	push hl
	; Load FieldX into hl
	ld hl, FieldX
	ld a, [hl+]
	ld l, [hl]
	ld h, a

	; Divide by 2 so that it lines up with path scrolling
	srl h ; Store bit 0 into carry
	rr  l ; Load bit 7 from carry

	; Load ObjX into de from stack
	pop bc
	push bc
	ld a, [bc]
	inc bc
	ld d, a
	ld a, [bc]
	inc bc
	ld e, a

	; ObjX - FieldX (as -FieldX + ObjX)
	;NegateHL
	add hl, de

	; Get low byte and exit
	ld a, l
	pop hl
	pop de
ret

TestFunction:
	InitRegistry
	RegisterPair TMP1, b, c
	RegisterPair TMP2, d, e
	RegisterPair TMP3, h, l
	InvalidatePair TMP1
	InvalidatePair TMP2
	RegisterPair TMP1, d, e
	MovePair TMP3, b, c
ret

; Replaces prepare and the various render routines
; HiRAM has a lot of variables, but no inputs
; de = output sprite location [input]
; hl = input object location [input]
PrepareObject:
CHAROFFSET = charInfo
	InitRegistry
	; input
	RegisterPair CHAR, h, l
	RegisterPair OAMBUFF, d, e

	; Stash OAM buffer so we have some more registers
	push de ; + 2
	InvalidatePair OAMBUFF

	; Load attributes into HiRAM
	ld a, CHAR_REF
	ldh [SpriteAttribs], a

	; Load Y into HiRAM
	SeekStructAndSet CHAROFFSET, charY, CHAR_HI, CHAR_LO
	ld a, CHAR_REF
	ldh [SpriteY], a

	; Calculate X and load into HiRAM
	SeekStructAndSet CHAROFFSET, charX, CHAR_HI, CHAR_LO
	call GetScreenX
	add a, CHAR_REF
	ldh [SpriteX], a

	; Get animation frame and load into HiRAM 
	; (going a bit out of order to save a register)
	SeekStructAndSet CHAROFFSET, charAnimFrame, CHAR_HI, CHAR_LO
	ld a, CHAR_REF ; @ charAnim
	sla a ; Multiply by 2
	ldh [SpriteFrame], a

	; Get the animation number
	SeekStructAndSet CHAROFFSET, charAnim, CHAR_HI, CHAR_LO
	ld a, CHAR_REF ; @ charAnim
	sla a

	; Set HL to next object and stash HL (it's now free!)
	SeekStructAndSet CHAROFFSET, charNext, CHAR_HI, CHAR_LO
	push CHAR_REG ; + 4
	InvalidatePair CHAR

	; Look up the animation offset (stored in A)
	RegisterPair ANIMOFF, d, e

	ld ANIMOFF_HI, HIGH(animations_pointers_start)
	add a, LOW(animations_pointers_start)
	jr nc, .nocarry_1
	inc ANIMOFF_HI
.nocarry_1
	ld ANIMOFF_LO, a

	; Get pointer to animation table into bc
	; de is now free
	RegisterPair ANIMTABLE, b, c
	ld a, ANIMOFF_REF
	ld ANIMTABLE_LO, a
	inc ANIMOFF_REG
	ld a, ANIMOFF_REF
	ld ANIMTABLE_HI, a
	InvalidatePair ANIMOFF

	; Get number of sprites and number of frames
	ld a, ANIMTABLE_REF
	inc ANIMTABLE_REG
	inc a ; For loop later
	ldh [SpriteCount], a ; Stash

	ld a, ANIMTABLE_REF
	inc ANIMTABLE_REG
	sla a
	ldh [SpriteSize], a

	inc ANIMTABLE_REG ; Skip loop point

	; Determine if we need to skip to right-facing mappings
	ld a, [SpriteAttribs]
	and a, %10000
	jr nz, .skipRightAdjust

	ld a, ANIMTABLE_REF
	sla a
	add a, ANIMTABLE_LO
	ld ANIMTABLE_LO, a
	jr nc, .nocarry_2
	inc ANIMTABLE_HI
.nocarry_2:
.skipRightAdjust:
	inc ANIMTABLE_REG ; Get to start of mapping list
	
	; Add SpriteFrame * 2 to mapping list
	ld h, 0
	ldh a, [SpriteFrame]
	ld l, a
	add hl, ANIMTABLE_REG
	ld ANIMTABLE_HI, h
	ld ANIMTABLE_LO, l

	RegisterPair OAMBUFF, h, l
	ld OAMBUFF_REG, sp+2 ; HL = OAM buffer
	ld a, OAMBUFF_REF
	inc OAMBUFF_REG
	ld d, a
	ld OAMBUFF_HI, OAMBUFF_REF
	ld OAMBUFF_LO, d
.loop:
	; Out of sprites?
	ldh a, [SpriteCount]
	dec a
	jr z, .endloop
	ldh [SpriteCount], a

	; Don't need original mapping list right now, do need registers ( + 6 )
	; I have the suspicision we can get rid of this push/pop
	push ANIMTABLE_REG 

	MovePair ANIMTABLE, d, e
	RegisterPair MAPOFF, b, c
	; Read mapping data for this frame
	ld a, [ANIMTABLE_REG]
	ld MAPOFF_LO, a
	inc ANIMTABLE_REG
	ld a, [ANIMTABLE_REG]
	ld MAPOFF_HI, a
	; de free, bc = mapping offset
	InvalidatePair ANIMTABLE

	RegisterSingle LOOPCOUNT, d
	; Get number of sub-sprites
	ld a, [MAPOFF_REG]
	ld LOOPCOUNT, a ; D is loop counter
	inc bc

.loop_subsprite:
	; Okay now we can finally write our output to OAM
	; Using E as temp

	ld a, MAPOFF_REF ; Y (adjust with stashed)
	ld e, a
	ldh a, [SpriteY]
	add a, e
	ld OAMBUFF_REF, a
	inc OAMBUFF_LO
	inc MAPOFF_REG

	ld a, MAPOFF_REF ; X (adjust with stashed)
	ld e, a
	ldh a, [SpriteX]
	add a, e
	ld OAMBUFF_REF, a
	inc OAMBUFF_LO
	inc MAPOFF_REG

	ld a, MAPOFF_REF ; Tile
	ld OAMBUFF_REF, a
	inc OAMBUFF_LO
	inc MAPOFF_REG

	ld a, MAPOFF_REF ; Metadata
	ld OAMBUFF_REF, a
	inc OAMBUFF_LO
	inc MAPOFF_REG

	dec LOOPCOUNTER
	jr nz, .loop_subsprite
.endloop_subsprite:

	; And now get the next sprite
	RegisterPair ANIMTABLE, b, c
	pop ANIMTABLE_REG ; ( + 4 )
	ldh a, [SpriteSize]
	add a, ANIMTABLE_LO
	ld ANIMTABLE_LO, a
	jr nc, .loop
	inc ANIMTABLE_HI
	jr .loop

.endloop:
LOOPCOUNT EQUS "INVALID"
	MovePair OAMBUFF, d, e
	RegisterPair CHAR, h, l
	pop CHAR_REG ; Object input ( + 2 )

	pop bc ; Discard OAM output ( + 0 )

ret

; Clobbers literally everything
; de = output sprite location
; hl = input object location
PrepareAllObjects:
	ld d, HIGH(SpriteTable)
	ld e, LOW(SpriteTable)
	ld hl, charStruct
	
	; We're going to need to keep bc on the stack...
	ldh a, [ActiveObjectsCount]
	ld b, a
	ldh a, [ActiveObjectsBitfield]
	ld c, a
.loop:
	rl c
	jr nc, .checkdone
	dec c

	push bc
	call PrepareObject
	pop bc

.checkdone
	ret z
	jr .loop

; Don't call directly!
SpriteDMA:
	ld a, SpriteTable / $100
	ldh [$FF46], a ;start DMA transfer (starts right after instruction)
	ld  a, $28     ;delay...
.wait:                 ;total 5x40 cycles, approx 200ms
	dec a          ;1 cycle
	jr  nz, .wait  ;4 cycles
	ret
SpriteDMA_End: