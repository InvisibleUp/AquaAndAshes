; Physics acceleration tables and stuff
MAXDX EQU 3
MAXDY EQU -4

; Number of frames button must be held for to accelerate
; Uses absolute value
AccelTable:
	DB 4 ; DX = 0
	DB 16 ; DX = 1
	DB 64 ; DX = 2
	DB 128 ; DX = 3
DeaccelTable:
	DB 32  ; DX = 0
	DB 16  ; DX = 1
	DB 8  ; DX = 2
	DB 4  ; DX = 3

; Create bitfield in a containing a list of active objects.
; This is clever because you can rr x; jr nc to skip easily.
; We're storing the result in HiRAM for easy access.
; Also includes number of active objects as it's own variable.
GenerateActiveObjectsBitfield:
	xor a
	ld b, a ; result
	ld c, a ; count

	ld d, a ; For incrementing HL
	ld e, charSizeOf

	ld hl, charStruct ; Initial pointer

REPT 7
	ld a, [hl] ; Get attributes
	add hl, de ; Increment HL to next object
	rla ; Set carry to active flag
	jr nc, .notactive\@ ; Skip if not active
	inc b ; Mark as active
	inc c ; Increment counter
.notactive\@:
	sla b ; Move b to the left
ENDR

; And one last time excluding the shift
	ld a, [hl] ; Get attributes
	add hl, de ; Increment HL to next object
	rla ; Set carry to active flag
	jr nc, .done ; Skip if not active
	inc b
	inc c
.done:

	; Save result
	ld a, b
	ldh [ActiveObjectsBitfield], a
	ld a, c
	ldh [ActiveObjectsCount], a

ret

; HL = pointer to beginning of given object
; Returned HL will be at charAnimSpeed
TickObject_Animation:
	; Set HL to charAnim
	ld d, 0
	ld e, charAnim
	add hl, de ; (HL @ charAnim)
; Set animation pointer to DE
	ld de, animations_pointers_start
	ld a, [hl+] ; A = animation #
	; Move HL to BC
	ld b, h
	ld c, l
	; HL = Animation frame *= 2
	rla
	ld h, 0
	ld l, a
	; Animation pointer (=HL) to relevant animation
	add hl, de

	; Set DE=[HL] (animation data)
	ld a, [hl+]
	ld e, a
	ld d, [hl]
	; Restore HL to be object pointer (@ charAnim)
	ld h, b
	ld l, c
	; Store # of frames in B
	inc de ; DE = # of frames
	ld a, [de]
	dec a ; Make zero-indexed
	ld b, a
	; Store current frame into C
	ld a, [hl+] ; HL @ charAnimFrame
	ld c, a

	; Get animation timer (range from AnimSpeed to 0)
	inc hl
	ld a, [hl-] ; HL @ charAnimSpeed
	or a
	ret nz ; Return if not time to animate

	; Set hl to animation frame
	dec hl ; charAnimFrame
	; Check if we need to loop the animation
	; (Check if current frame == number of frames)
	ld a, b
	sub a, c
	jr z, .needsLoop
	
	; Increment animation frame, FFW hl, return
	inc [hl] ; @ charAnimFrame
	inc hl ; @ charAnimSpeed
	ret

.needsLoop
	; Check what action we need to do
	inc de ; DE = Loop Action
	ld a, [de]
	rla ; Carry = action type
	jr nc, .getFrame

	; Set animation to a
	srl a ; This is equal to [de] & %01111111
	dec hl ; HL @ charAnimFrame
	ld [hl+], a ; HL @ charAnimSpeed

	; Set frame to 0
	xor a
	jr .setFrame

.getFrame:
	; Adjust [de] to be frame #
	srl a

.setFrame:
	; Store animation frame into object RAM and return
	ld [hl+], a ; HL @ charAnimSpeed
ret

TickObject_Timer: ; (HL @ charAnimSpeed)
	; Get animation speed and current timer value
	ld a, [hl+]
	ld b, [hl]
	; Check if speed == value
	sub a, b
	jr z, .resetTimer
	; Increment timer
	inc b
	ld [hl], b
	jr .done
.resetTimer:
	; Set timer = 0
	xor a
	ld [hl], a
.done:
	; Set HL to next object attributes and return
	ld bc, (charSizeOf - charAnimTimer)
	add hl, bc
	ret

TickObject_Physics:

	; Get dX and dY
	ld de, (charDx)
	add hl, de ; @ charDx
	ld c, [hl] ; C = charDx
	
	inc hl     ; @ charDy
	ld b, [hl]

	; Move object pointer to Y
	ld a, 255
	xor a, e
	ld e, a
	inc e
	ld d, 255
	add hl, de ; @ charY

.addY:
	; Add dY to Y
	ld a, [hl]
	add a, b
	ld [hl+], a ; @ charX.1

.addX
	; Move HL to DE
	ld d, h
	ld e, l

	; Sign-extend C into B
	ld a, c
	rla
	ld a, 0
	ld b, 0
	sbc b
	ld b, a

	; Set HL to [DE]
	ld a, [de]
	ld h, a
	inc de ; @ charX.2
	ld a, [de]
	ld l, a
	dec de ; @ charX.1

	; Add BC to HL
	add hl, bc

	; Write HL to [DE]
	ld a, h
	ld [de], a
	ld a, l
	inc de ; @ charX.2
	ld [de], a

	; Restore HL
	ld h, d
	ld l, e

	; Rewind and exit
	dec hl ; @charX.1
	dec hl ; @charY
	dec hl ; @charInfo
	ret

TickObject_PlayerInput:
	; Store charInfo somewhere
;	ld a, [hl]

	; FFW HL to dX
	push hl
	ld de, (charDx)
	add hl, de

;	ld d, a ; D = charInfo

; Move player with keys
; We want to deaccelerate when:
;	- Player has let go of all buttons
;	- Player is trying to go opposite of DX
; We want to accelerate when:
;	- Player is not moving but is pressing a button
;	- Player is trying to go same as DX

	; Are we pressing any buttons?
	ldh a, [JoypadButtons]
;	ld a, [GlobalTimer]
;	bit 6, a
;	jr z, .tmp1
;	ld a, $10
;	jr .tmp2
;.tmp1:
;	ld a, $20
;.tmp2:
	ld b, a ; B = Joypad buttons
	or a
	jr z, .doDeaccel ; Nothing is pressed

	and a, %00110000
	ld c, a ; C = left/right this frame

	ld a, [hl] ; Load DX into a
	or a ; Have we JUST started moving?
	;or c
	jr z, .doAccel ; If so, accelerate
	
	; Are we pressing the opposite direction as dX?
	; What I need:
	; sign(DX) is positive (right) and left is pressed or
	; sign(DX) is negative (left) and right is pressed:
	; then deaccelerate
	; TODO: Condense this a bit

	bit 7, [hl]
	jr z, .checkRight

.checkLeft: ; Moving left
	ld a, c
	and a, $10 ; Pressing left?
	jr z, .doAccel ; Accelerate
	jr .doDeaccel

.checkRight:
	ld a, c
	and a, $20 ; Pressing right?
	jr z, .doAccel ; Accelerate

.doDeaccel
	; Round towards zero
	; B is free here

	; Are we already stopped?
	ld b, [hl]
	ld a, b
	or a
	jr z, .noAccel

	sla b ; CF = sign (if negative, = 1)
	; D U L R X X X X
	; We're going to shift 1 left if carry flag is off.
	ld b, 1
	jr c, .noShift
	sla b
.noShift:
	swap b ; And this is our fake joystick input
	ld a, [hl]
	AbsA
	push hl
	ld hl, DeaccelTable ; With our deacceleration table
	jr .addSpeedToTable

.doAccel:
	; Only allow this every nth frame depending on lookup table
	ld a, [hl]
	AbsA
	push hl
	ld hl, AccelTable
.addSpeedToTable:
	add a, l
	ld l, a
	jr nc, .nocarry
	inc h
.nocarry:
	ld a, [ButtonStreak]
	;and a, [hl]
	sub a, [hl]
	pop hl
	jr c, .noAccel

	; Test buttons
	bit PADB_LEFT, b
	jr z, .notLeft

	dec [hl]
	jr .notRight
.notLeft:
	bit PADB_RIGHT, b
	jr z, .notRight

	inc [hl]
.notRight

; Cap dX
	ld a, [hl]
	AbsA
	sub a, MAXDX
	jr c, .skipCap
	jr z, .skipCap
	
	bit 7, [hl]
	jr z, .capPos
	inc [hl]
	jr .skipCap
.capPos:
	dec [hl]
.skipCap:
.noAccel:


; Restore HL and return
	pop hl
	ret

TickObject_AI_Offense:
	ret
TickObject_AI_Defense:
	ret

; HL @ attributes
TickObject_Offense:
; Our team?
	ld b, [hl] ; B = attributes
	ld a, [TurnInfo] ; Bit 7 = team #

	; Check if bit 6 of B = bit 7 of A
	rl b
	and a, b ; Bit 7 is 1 if player team = object team
	rla ; Carry flag has our answer. 
	; B = attributes, shifted left 1
	; A is garbage
	jr nc, .enemyTeam
	; Jump to player input routine
	jp TickObject_PlayerInput
.enemyTeam
; Our turn?
	; Check if (now) bit 7 of B = bit 7 of A
	ld a, [TurnInfo]
	rla
	and a, b
	rla ; Carry flag is 1 if offense team = object team
	jp c, TickObject_AI_Offense ; Do offense stuff
	jp TickObject_AI_Defense ; Try and stop player's offense

; HL = object offset
TickObject:
; Get attributes in compact form
	ld a, [hl]
	rla
	ret nc ; Return if not active
	; A = [team],[type],[dir],[position],X,X,X,X
	; Check if type == football, and if so, skip this all
	bit 6, a
	jr nz, .AnimalActionDone
	; Otherwise "call" the proper dispatch function
	; Push the return address so that ret still works, but we
	; don't have to fiddle with jumps after the call
	ld bc, .AnimalActionDone
	push bc
	bit 4, a
	jp z, TickObject_Offense
	jp TickObject_AI_Defense ; All defense is AI controlled

.AnimalActionDone:
	; Do physics stuff
	call TickObject_Physics
	; Do animaton stuff
	call TickObject_Animation ; (HL @ charAnimSpeed)
	; Update timer
	call TickObject_Timer ; (HL @ next object)
ret

; Call TickObject for all objects
TickAllObjects:
	ld hl, charStruct
	; We're going to need to keep bc on the stack...
	ldh a, [ActiveObjectsCount]
	ld b, a
	ldh a, [ActiveObjectsBitfield]
	ld c, a
.loop:
	rl c
	jr nc, .checkdone
	dec b

	push bc
	call TickObject
	pop bc

.checkdone
	ld a, b
	or a
	ret z
	jr .loop

; Just the definition for a sample object
SampleObject:
	DB %11010000 ; charInfo (snowfox, left)
	DB FieldHeight
	DW $0080 ; X
	DB 0 ; Animation
	DB 0 ; Frame
	DB 5 ; Animation Speed
	DB 0 ; Animation Timer
	DB 0 ; Dx
	DB 0 ; Dy
