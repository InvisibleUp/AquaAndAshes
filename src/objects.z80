; Physics acceleration tables and stuff
MAXDX EQU 3
MAXDY EQU -4

; Number of frames button must be held for to accelerate
; Uses absolute value
AccelTable:
	DB 4 ; DX = 0
	DB 16 ; DX = 1
	DB 64 ; DX = 2
	DB 90 ; DX = 3
DeaccelTable:
	DB 32  ; DX = 0
	DB 16  ; DX = 1
	DB 8  ; DX = 2
	DB 4  ; DX = 3

; Create bitfield in a containing a list of active objects.
; This is clever because you can rr x; jr nc to skip easily.
; We're storing the result in HiRAM for easy access.
; Also includes number of active objects as it's own variable.
GenerateActiveObjectsBitfield:
	xor a
	ld b, a ; result
	ld c, a ; count

	ld d, a ; For incrementing HL
	ld e, charSizeOf

	ld hl, charStruct ; Initial pointer

REPT 7
	ld a, [hl] ; Get attributes
	add hl, de ; Increment HL to next object
	rla ; Set carry to active flag
	jr nc, .notactive\@ ; Skip if not active
	inc b ; Mark as active
	inc c ; Increment counter
.notactive\@:
	sla b ; Move b to the left
ENDR

; And one last time excluding the shift
	ld a, [hl] ; Get attributes
	add hl, de ; Increment HL to next object
	rla ; Set carry to active flag
	jr nc, .done ; Skip if not active
	inc b
	inc c
.done:

	; Save result
	ld a, b
	ldh [ActiveObjectsBitfield], a
	ld a, c
	ldh [ActiveObjectsCount], a

ret

; HL = pointer to beginning of given object
; Returned HL will be at charAnimSpeed
TickObject_Animation:
CHAROFFSET = charInfo

	; Set HL to charAnim
	SeekStructAndSet CHAROFFSET, charAnim, h, l
	; Set animation pointer to DE
	ld de, animations_pointers_start
	ld a, [hl] ; A = animation #
	; Move HL (object struct) to stack
	ld b, h
	ld c, l

	; HL = Animation frame *= 2
	rla
	ld h, 0
	ld l, a
	; Animation pointer (=HL) to relevant animation
	add hl, de

	; Set DE=[HL] (animation data)
	ld a, [hl+]
	ld e, a
	ld d, [hl]

	; Restore HL to be object pointer (@ charAnim)
	ld h, b
	ld l, c
CHAROFFSET = charAnim
	; Store # of frames in B
	inc de ; DE = # of frames
	ld a, [de]
	dec a ; Make zero-indexed
	ld b, a
	; Store current frame into C
	SeekStructAndSet CHAROFFSET, charAnimFrame, h, l
	ld a, [hl]
	ld c, a

	; Get animation timer (range from AnimSpeed to 0)
	SeekStructAndSet CHAROFFSET, charAnimTimer, h, l
	ld a, [hl]
	or a
	jr nz, .return ; Return if not time to animate

	; Set hl to animation frame
	SeekStructAndSet CHAROFFSET, charAnimFrame, h, l
	; Check if we need to loop the animation
	; (Check if current frame == number of frames)
	ld a, b
	sub a, c
	jr z, .needsLoop
	
	; Increment animation frame, FFW hl, return
	inc [hl] ; @ charAnimFrame
	jr .return

.needsLoop
	; Check what action we need to do
	inc de ; DE = Loop Action
	ld a, [de]
	rla ; Carry = action type
	jr nc, .getFrame

	; Set animation to a
	srl a ; This is equal to [de] & %01111111
	SeekStructAndSet CHAROFFSET, charAnim, h, l
	ld [hl], a 

	; Set frame to 0
	xor a
	jr .setFrame

.getFrame:
	; Adjust [de] to be frame #
	srl a

.setFrame:
	; Store animation frame into object RAM and return
	ld [hl], a

.return
	SeekStructAndSet CHAROFFSET, charAnimSpeed, h, l
ret

TickObject_Timer:
CHAROFFSET = charAnimSpeed
	; Get animation speed and current timer value
	ld a, [hl]
	SeekStructAndSet CHAROFFSET, charAnimTimer, h, l
	ld b, [hl]
	; Check if speed == value
	sub a, b
	jr z, .resetTimer
	; Increment timer
	inc b
	ld [hl], b
	jr .done
.resetTimer:
	; Set timer = 0
	xor a
	ld [hl], a
.done:
	; Set HL to next object attributes and return
	SeekStructAndSet CHAROFFSET, charNext, h, l
	ret

; Runs 1 frame of player physics
; HL = Player object pointer
; A, BC, DE are clobbered
TickObject_Physics:
CHAROFFSET = charInfo
	push hl

	; Get dX and dY
	;ld de, (charDx)
	;add hl, de ; @ charDx
	SeekStructAndSet CHAROFFSET, charDx, h, l
	ld c, [hl] ; C = charDx
	
	;inc hl     ; @ charDx.2
	;inc hl     ; @ charDy
	SeekStructAndSet CHAROFFSET, charDy, h, l
	ld b, [hl]

	; Move object pointer (hl) to Y
	SeekStructAndSet CHAROFFSET, charY, h, l

.addY:
	; Add dY to Y
	ld a, [hl]
	add a, b
	ld [hl], a

.addX
	SeekStructAndSet CHAROFFSET, charX, h, l
	push hl

	; Sign-extend C (dX) into B
	ld a, c
	rla
	ld a, 0
	ld b, 0
	sbc b
	ld b, a

	; Set HL to [DE]
	pop de
CHAROFFSET = charX
	ld a, [de]
	ld h, a
	SeekStructAndSet CHAROFFSET, charX+1, d, e
	ld a, [de]
	ld l, a

	; Add BC (dX) to HL
	add hl, bc

	; Write HL to [DE]
	SeekStructAndSet CHAROFFSET, charX, d, e
	ld a, h
	ld [de], a
	SeekStructAndSet CHAROFFSET, charX+1, d, e
	ld a, l
	ld [de], a

	; Rewind and exit
	pop hl
	ret

TickObject_PlayerInput:
CHAROFFSET = charInfo
	; FFW HL to dX
	push hl
	push hl ; need it twice

	SeekStructAndSet CHAROFFSET, charDx, h, l

; Move player left/right with keys
; We want to deaccelerate when:
;	- Player has let go of all buttons
;	- Player is trying to go opposite of DX
; We want to accelerate when:
;	- Player is not moving but is pressing a button
;	- Player is trying to go same as DX

	; Are we pressing any buttons?
	ldh a, [JoypadButtons]
	ld b, a ; B = Joypad buttons
	and a, PADF_RIGHT | PADF_LEFT
	jr z, .doDeaccel ; Nothing is pressed

	ld c, a ; C = left/right this frame

	ld a, [hl] ; Load DX into a
	or a ; Have we JUST started moving?
	;or c
	jr z, .doAccel ; If so, accelerate
	
	; Are we pressing the opposite direction as dX?
	; TODO: Condense this a bit

	bit 7, [hl]
	jr z, .checkRight

.checkLeft: ; Moving left
	ld a, c
	and a, PADF_RIGHT
	jr z, .doAccel ; Accelerate
	jr .doDeaccel

.checkRight:
	ld a, c
	and a, PADF_LEFT
	jr z, .doAccel ; Accelerate

.doDeaccel
	; Round towards zero
	; B is free here

	; Are we already stopped?
	ld b, [hl]
	ld a, b
	or a
	jr z, .noAccel

	sla b ; CF = sign (if negative, = 1)
	; D U L R X X X X
	; We're going to shift 1 left if carry flag is off.
	ld b, 1
	jr c, .noShift
	sla b
.noShift:
	swap b ; And this is our fake joystick input
	ld a, [hl]
	AbsA
	push hl
	ld hl, DeaccelTable ; With our deacceleration table
	jr .addSpeedToTable

.doAccel:
	; Only allow this every nth frame depending on lookup table
	ld a, [hl]
	AbsA
	push hl
	ld hl, AccelTable
.addSpeedToTable:
	add a, l
	ld l, a
	jr nc, .nocarry
	inc h
.nocarry:
	ld a, [DirButtonStreak]
	sub a, [hl]
	pop hl
	jr c, .noAccel

	; Test buttons
	bit PADB_LEFT, b
	jr z, .notLeft

	dec [hl]
	jr .notRight
.notLeft:
	bit PADB_RIGHT, b
	jr z, .notRight

	inc [hl]
.notRight

; Cap dX
	ld a, [hl]
	AbsA
	sub a, MAXDX
	jr c, .skipCap
	jr z, .skipCap
	
	bit 7, [hl]
	jr z, .capPos
	inc [hl]
	jr .skipCap
.capPos:
	dec [hl]
.skipCap:
.noAccel:

	jr .noJump ; DEBUG: Skip this for now

; HL @ DX
; Handle jumping if A button is pressed
.checkJump:
	ldh a, [JoypadButtons]
	and a, PADF_A
	jr z, .noJump ; Nothing is pressed

	; Rewind HL to Y and load into D
	inc hl ; @ CharDy
	ld b, h
	ld c, l
	pop hl ; @ CharInfo
	inc hl ; @ CharY
	ld d, [hl]

	; FFW HL back to DY
	ld h, b
	ld l, c

	; Load JumpButtonStreak into E
	ld a, [JumpButtonStreak]
	ld e, a

	; If Y != floor level and JumpButtonStreak == 0, return
	ld a, FieldHeight
	sub a, d ; D is free
	jr z, .checkJumpStreak ; JR if Y == floor level
	
	ld a, b
	or a
	jr nz, .noJump
.checkJumpStreak:
	; If JumpButtonStreak > 16, return
	ld a, e
	sub a, 17
	jr nc, .noJump

.doJump:
	; If streak % 8 != 0, skip jump
	ld a, e
	and a, %1111
	jr nz, .noJump
	; Decrement DY
	dec [hl]

; Restore HL and return
.noJump:
	pop hl
	ret

TickObject_AI_Offense:
	ret
TickObject_AI_Defense:
	ret

; HL @ attributes
TickObject_Offense:
; Our team?
	ld b, [hl] ; B = attributes
	ld a, [TurnInfo] ; Bit 7 = team #

	; Check if bit 6 of B = bit 7 of A
	rl b
	and a, b ; Bit 7 is 1 if player team = object team
	rla ; Carry flag has our answer. 
	; B = attributes, shifted left 1
	; A is garbage
	jr nc, .enemyTeam
	; Jump to player input routine
	;jp TickObject_PlayerInput
.enemyTeam
; Our turn?
	; Check if (now) bit 7 of B = bit 7 of A
	ld a, [TurnInfo]
	rla
	and a, b
	rla ; Carry flag is 1 if offense team = object team
	jp c, TickObject_AI_Offense ; Do offense stuff
	jp TickObject_AI_Defense ; Try and stop player's offense

; HL = object offset
TickObject:
; Get attributes in compact form
	ld a, [hl]
	rla
	ret nc ; Return if not active
	; A = [team],[type],[dir],[position],X,X,X,X
	; Check if type == football, and if so, skip this all
	bit 6, a
	jr nz, .AnimalActionDone
	; Otherwise "call" the proper dispatch function
	; Push the return address so that ret still works, but we
	; don't have to fiddle with jumps after the call
	ld bc, .AnimalActionDone
	push bc
	bit 4, a
	jp z, TickObject_Offense
	jp TickObject_AI_Defense ; All defense is AI controlled

.AnimalActionDone:
	; Do physics stuff
	call TickObject_Physics
	; Do animaton stuff
	call TickObject_Animation ; (HL @ charAnimSpeed)
	; Update timer
	call TickObject_Timer ; (HL @ next object)
ret

; Call TickObject for all objects
TickAllObjects:
	ld hl, charStruct
	; We're going to need to keep bc on the stack...
	ldh a, [ActiveObjectsCount]
	ld b, a
	ldh a, [ActiveObjectsBitfield]
	ld c, a
.loop:
	rl c
	jr nc, .checkdone
	dec b

	push bc
	call TickObject
	pop bc

.checkdone
	ld a, b
	or a
	ret z
	jr .loop

; Just the definition for a sample object
SampleObject:
	DB %11010000 ; charInfo (snowfox, left)
	DB FieldHeight, $00
	DB $00, $80, $00 ; X
	DB 0 ; Animation
	DB 0 ; Frame
	DB 5 ; Animation Speed
	DB 0 ; Animation Timer
	DB 0 ; Dx
	DB 0 ; Dy
