; Fills a range in memory with a specified byte value.
; hl = destination address
; bc = byte count
; a = byte value
memset:
    inc c
    inc b
    jr .start
.repeat:
    ld [hl+], a
.start:
    dec c
    jr nz, .repeat
    dec b
    jr nz, .repeat
ret

; Copies count bytes from source to destination.
; de = destination address
; hl = source address
; bc = byte count
memcpy:
    inc c
    inc b
    jr .start
.repeat:
    ld a, [hl+]
    ld [de], a
    inc de
.start:
    dec c
    jr nz, .repeat
    dec b
    jr nz, .repeat
ret

;;; STRUCT TRAVERSAL HELPERS ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Macro for moving to a specific element
; No register use guarantee! (maybe except for A?)
; in a structure starting from a previous one
; \1 = Source address
; \2 = Dest address
; \3 = High register to increment
; \4 = Low register to increment
; TODO: Optimize for large distances
SeekStruct: MACRO
offset = \2 - \1
    
IF offset > 0
    .rept offset
        inc \3\4
    endr
ELIF offset < 0
    .rept offset
        dec \3\4
    endr
ENDC
ENDM

; Same as SeekStruct, except \1 is a SETable
SeekStructAndSet: MACRO
offset = \2 - \1
\1 = \1 + offset
    SeekStruct \1, \2, \3, \4
ENDM

; TODO: SeekStructAtHLWithLD(AndSet) 
; which is a terrible name for a macro that increments/
; decrements HL with a load before calling SeekStrut

;;; REGISTER/MEMORY LABEL DEFINITON HELPERS ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

InitRegistry: MACRO
REGISTRY_IN_USE = 1
a_SET = 0
b_SET = 0
c_SET = 0
d_SET = 0
e_SET = 0
h_SET = 0
l_SET = 0
ENDM

; Defines names for a pair of registers
; \1 = Prefix name, all caps
; \2 = first register in pair
; \3 = second register in pair
; Defines names \1_HI, \1_LO, \1_REG, \1_REF
; Checks against variables \2_SET, \3_SET
RegisterPair: MACRO
PRINTT "\1: \2\3\n"

IF \2_SET == 1
FAIL "\2 is already set!"
ENDC

IF \3_SET == 1
FAIL "\3 is already set!"
ENDC

\2_SET = 1
\3_SET = 1

\1_HI EQUS "\2"
\1_LO EQUS "\3"
\1_REG EQUS "\2\3"
\1_REF EQUS "[\2\3]"
ENDM

; Marks a macro pair as invalid
; \1 = Prefix name, all caps
InvalidatePair: MACRO
PRINTT "\1: INVALID\n"

\1_HI_SET = 0
PURGE \1_HI
;\1_HI EQUS "INVALID"
\1_LO_SET = 0
PURGE \1_LO
PURGE \1_REG
PURGE \1_REF
;\1_LO EQUS "INVALID"
;\1_REG EQUS "INVALID"
;\1_REF EQUS "INVALID"
ENDM

; Moves a pair to another set of registers, with contents
; \1 = old pair name
; \2 = new pair lo
; \3 = new pair hi
MovePair: MACRO
PRINTT "\1 -> \2\3\n"
IF \2_SET == 1
FAIL "\2 is already set!"
ENDC

IF \3_SET == 1
FAIL "\3 is already set!"
ENDC

    ld \2, \1_HI
    ld \3, \1_LO
    InvalidatePair \1
    RegisterPair \1, \2, \3

ENDM

; Registers a single register
; \1 = label name
; \2 = register
RegisterSingle: MACRO
IF \2_SET == 1
FAIL "\2 is already set!"
ENDC

\2_SET = 1

\1 EQUS "\2"
\1_SET EQUS "\2_SET"
ENDM

; Unregisters a single register
; \1 = label name
InvalidateSingle: MACRO
\1_SET = 0
;PURGE \1
\1 EQUS "INVALID"
ENDM