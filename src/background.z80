; Update parallax background timers
; Run once per increment of ScrollX
incFieldX:
	ld hl, FieldX
	ld a, [hl+]
	ld e, a
	ld d, [hl]
	inc de
	ld a, d
	ld [hl-], a
	ld a, e
	ld [hl], a

	ld a, [GlobalTimer]
	ld b, a
	ld hl, ParallaxLayer1

.Layer1:
	; Top updates every 4 frames
	and a, %11
	jr nz, .Layer2
	inc [hl]
.Layer2:
	inc hl
	ld b, a
	call Modulo3
	or a
	jr nz, .Layer3
	inc [hl]
.Layer3:
	inc hl
	rra
	jr c, .return
	inc [hl]
.return:
	ret

; Update parallax background timers
; Run once per decrement of ScrollX
decFieldX:
	ld hl, FieldX
	ld a, [hl+]
	ld d, a
	ld e, [hl]
	inc de
	ld a, e
	ld [hl-], a
	ld [hl], d

	ld a, [GlobalTimer]
	ld b, a
	ld hl, ParallaxLayer1

.Layer1:
	; Top updates every 4 frames
	and a, %11
	jr nz, .Layer2
	dec [hl]
.Layer2:
	inc hl
	ld b, a
	call Modulo3
	or a
	jr nz, .Layer3
	dec [hl]
.Layer3:
	inc hl
	rra
	jr c, .return
	dec [hl]
.return:
	ret	

; LCD STAT interupt routine for parallax scrolling
scrollLayer:
	push af

	; Set scroll position from current scanline
	ld a, [rLY]
	sub a, MinScanline ; No scanline effects before minimum (to save RAM)
	jr c, .exit 

	rla ; Double A (we know carry is 0!)

	push hl
	ld hl, ScanlineBuffer
	add a, l
	ld l, a
	ld a, [hl+]	; Increment HL to next line pointer
	ldh [rSCX], a

	; Set next scanline
	ld a, [hl]
	ldh [rLYC], a
	pop hl

.exit:
	pop af
	reti

; Call this after every VBlank
resetScrollLayer:
	xor a
	ldh [rSCX], a

	ret
